#!/usr/bin/env bash
#
# Setups parse-server, in an easy fashion
# Used for running Test Cases against the parse-php-sdk
#

############
## Config ##
############

# app name
APP_NAME="MyTestApp"

# application id
APP_ID="app-id-here"

# master key
MASTER_KEY="master-key-here"

# mongodb database uri
DATABASE_URI="mongodb://localhost/test"

# location of cloud code file (this location)
#CLOUD_CODE_FILE="`pwd`/cloud-code.js"
CLOUD_CODE_FILE="`dirname $0`/cloud-code.js"

# parse push configuration (mock and android only)
PUSH_CONFIG='{"android":{"senderId":"blank-sender-id","apiKey":"not-a-real-api-key"}}'

# email adapter configuration, default is mailgun with nonfunctional keys
EMAIL_ADAPTER_CONFIG='{"module":"parse-server-simple-mailgun-adapter","options":{"apiKey":"not-a-real-api-key","domain":"example.com","fromAddress":"example@example.com"}}'

# parse server publicly accessible url
PUBLIC_URL="http://localhost:1337/parse"

# auth data
AUTH_DATA='{"twitter":{"consumer_key":"not_a_real_consumer_key","consumer_secret":"not_a_real_consumer_secret"},"facebook":{"appIds":"not_a_real_facebook_app_id"}}'

# live query setup
LIVE_QUERY_CLASS_NAME='TestObject,User,_User';



# Verify we are not already running
if [ -f "`dirname $0`/pid.txt" ];
then
    PID=$(<"`dirname $0`/pid.txt")
    if [ ! "$PID" = "" ];
    then
        # server already running
        echo "
parse-server appears to be already running under process [$PID]

Run 'npm stop' first to shut it down.
"
        exit 0

    fi

fi

# check to update our dependencies before we begin
npm update

# Start MongoDB
mongodb-runner start

# space out commands from mongodb-runner
echo "
"

# generated log file for this test instance, does NOT rotate
LOG_FILE="parse-server-`date '+%m-%d-%Y'`.log"
LOG_PATH="`dirname $0`/"

# Writes the server PID out once finished starting up
function writePID {

    # wait until the log file is created
    while [ ! -f "$1" ];
    do
        sleep 1

    done

    # wait for parse to start logging
    OUTPUT=$(<"$1")
    while [ "$OUTPUT" = "" ];
    do
        sleep 1
        OUTPUT=$(<"$1")

    done

    # setup regex
    GREP_REGEX="\[[0-9]+\] parse-server running"

    # get line in question containing our PID
    PID=`cat "$1" | egrep "$GREP_REGEX"`

    # wait for our server running line to load up
    while [ "$PID" = "" ];
    do
        sleep 1
        PID=`cat "$1" | egrep "$GREP_REGEX"`

    done

    # Pull out just the first part, containing the PID
    PID=($PID)

    # convert [] to pipes
    PID=$(echo "$PID"|tr -d "[\`|")
    PID=$(echo "$PID"|tr -d "]\`|")

    # split on pipes to get our PID
    PID=`echo $PID | cut -d '|' -f 2`

    #PID=`echo $!`
    echo "$PID" > "`dirname $0`/pid.txt"

}

# Start ParseServer from the command line, note we are using cloud code as well
parse-server\
    --appName $APP_NAME\
    --appId $APP_ID\
    --masterKey $MASTER_KEY\
    --databaseURI $DATABASE_URI\
    --cloud $CLOUD_CODE_FILE\
    --push $PUSH_CONFIG\
    --emailAdapter $EMAIL_ADAPTER_CONFIG\
    --publicServerURL $PUBLIC_URL\
    --auth $AUTH_DATA\
    --liveQuery.classNames $LIVE_QUERY_CLASS_NAME\
    --startLiveQueryServer true\
    > "$LOG_PATH$LOG_FILE" 2>&1\
    & writePID "$LOG_PATH$LOG_FILE" &

# loop until the pid exists
while [ ! -f "`dirname $0`/pid.txt" ];
do
    echo "no pid found..."
    sleep 1

done

# loop until the PID is written out
PID=$(<"`dirname $0`/pid.txt")
while [ "$PID" = "" ];
do
    sleep 2
    PID=$(<"`dirname $0`/pid.txt")
done

echo "
[Parse Server Started with PID $PID]
Logging to $LOG_FILE
"

exit 0